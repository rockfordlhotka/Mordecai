@page "/dungeon"
@using Mordecai.Services
@layout DungeonLayout
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject ChatService ChatService
@inject GameService GameService
@inject IServiceProvider ServiceProvider
@rendermode InteractiveServer

<PageTitle>Dungeon - Mordecai</PageTitle>

<link href="@Assets["css/dungeon.css"]" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet" />

@if (!isPlayerConnected)
{
    <div class="login-container">
        <a href="/" class="login-back-button" title="Return to main menu">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.42-1.41L7.83 13H20v-2z"/>
            </svg>
        </a>
        
        <div class="banner">
            <div class="wood-grain"></div>
            <div class="title">Mordecai</div>
            <div class="moss-accent"></div>
            <div class="corner-vine"></div>
        </div>
        
        <div class="login-form">
            <h2>Enter the Dungeon</h2>
            <div class="input-group">
                <input @bind="playerName" 
                       @onkeyup="HandleLoginKeyUp"
                       @ref="loginInputElement"
                       type="text" 
                       class="player-name-input" 
                       placeholder="Enter your character name..." 
                       maxlength="20" />
                <button @onclick="JoinDungeon" class="join-button" disabled="@(string.IsNullOrWhiteSpace(playerName))">
                    Enter Dungeon
                </button>
            </div>
        </div>
    </div>
}
else
{
    <div class="dungeon-container">
        <div class="game-header">
            <div class="header-left">
                <a href="/" class="back-button" title="Return to main menu">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.42-1.41L7.83 13H20v-2z"/>
                    </svg>
                </a>
                <div class="player-info">
                    <span class="player-name">@playerName</span>
                    <span class="player-count">(@connectedPlayers.Count players online)</span>
                </div>
            </div>
            <div class="connected-players">
                @foreach (var player in connectedPlayers)
                {
                    <span class="player-tag">@player</span>
                }
            </div>
        </div>
        
        <div class="game-output" id="gameOutput">
            @foreach (var message in gameMessages)
            {
                <div class="message @GetMessageClass(message.Type)">
                    <span class="timestamp">[@message.Timestamp.ToString("HH:mm:ss")]</span>
                    @if (message.Type == ChatMessageType.Chat)
                    {
                        <span class="player-name-tag">@message.PlayerName:</span>
                    }
                    <span class="content">@message.Content</span>
                </div>
            }
        </div>
        
        <div class="input-container">
            <div class="input-group">
                <input @bind="currentInput" 
                       @onkeyup="HandleKeyUp"
                       @ref="inputElement"
                       type="text" 
                       class="command-input" 
                       placeholder="@GetInputPlaceholder()" 
                       maxlength="200" />
                <button @onclick="SendMessage" class="send-button" disabled="@isProcessing">
                    <svg class="arrow-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z" />
                    </svg>
                </button>
            </div>
            <div class="input-help">
                <span>Commands: /help, /who, /say &lt;message&gt; | Game: look [direction], north, south, east, west, inventory</span>
            </div>
        </div>
    </div>
}

@code {
    private string currentInput = "";
    private string playerName = "";
    private bool isProcessing = false;
    private bool isPlayerConnected = false;
    private ElementReference inputElement;
    private ElementReference loginInputElement;
    private List<ChatMessage> gameMessages = new();
    private List<string> connectedPlayers = new();
    private string? connectionId;

    protected override void OnInitialized()
    {
        // Player will need to connect first
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !isPlayerConnected)
        {
            await loginInputElement.FocusAsync();
        }
        else if (isPlayerConnected)
        {
            await inputElement.FocusAsync();
        }
        
        // Auto-scroll to bottom
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "gameOutput");
    }

    private async Task HandleLoginKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(playerName))
        {
            await JoinDungeon();
        }
    }

    private async Task JoinDungeon()
    {
        if (string.IsNullOrWhiteSpace(playerName))
            return;

        playerName = playerName.Trim();
        
        try
        {
            connectionId = await ChatService.ConnectPlayerAsync(playerName, OnMessageReceived);
            isPlayerConnected = true;
            
            // Update connected players list
            connectedPlayers = ChatService.GetConnectedPlayers();
            
            // Add welcome message
            await OnMessageReceived(new ChatMessage
            {
                Type = ChatMessageType.System,
                Content = "Welcome to the Dungeon of Mordecai! You are now connected to the multiplayer realm.",
                Timestamp = DateTime.Now,
                PlayerName = "System"
            });
            
            // Get the player's current room description
            var roomDescription = await GameService.GetRoomDescriptionAsync(playerName);
            await OnMessageReceived(new ChatMessage
            {
                Type = ChatMessageType.Description,
                Content = roomDescription,
                Timestamp = DateTime.Now.AddSeconds(1),
                PlayerName = "Game"
            });

            // Notify other players in the starting room that this player has arrived
            using (var scope = ServiceProvider.CreateScope())
            {
                var gameService = scope.ServiceProvider.GetRequiredService<GameService>();
                var player = await gameService.GetPlayerByNameAsync(playerName);
                if (player?.CurrentRoomId != null)
                {
                    await ChatService.BroadcastMovementAsync(
                        player.CurrentRoomId.Value,
                        playerName,
                        $"{playerName} materializes into existence.",
                        connectionId);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Handle connection error
            Console.WriteLine($"Failed to connect: {ex.Message}");
        }
    }

    private async Task OnMessageReceived(ChatMessage message)
    {
        await InvokeAsync(() =>
        {
            gameMessages.Add(message);
            
            // Update connected players if it's a join/leave message
            if (message.Type == ChatMessageType.System)
            {
                connectedPlayers = ChatService.GetConnectedPlayers();
            }
            
            StateHasChanged();
        });
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isProcessing)
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentInput) || isProcessing || connectionId == null)
            return;

        isProcessing = true;
        var input = currentInput.Trim();
        currentInput = "";
        StateHasChanged();

        try
        {
            // Check if it's a chat command
            if (input.StartsWith("/"))
            {
                await ProcessChatCommand(input);
            }
            else
            {
                // It's a game command
                await ProcessGameCommand(input);
            }
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task ProcessChatCommand(string command)
    {
        var parts = command.Split(' ', 2);
        var cmd = parts[0].ToLower();

        switch (cmd)
        {
            case "/help":
                await OnMessageReceived(new ChatMessage
                {
                    Type = ChatMessageType.System,
                    Content = "Chat Commands: /say <message>, /who, /thunder (test) | Game Commands: help, look [direction], north, south, east, west, inventory",
                    Timestamp = DateTime.Now,
                    PlayerName = "System"
                });
                break;

            case "/who":
                var players = string.Join(", ", connectedPlayers);
                await OnMessageReceived(new ChatMessage
                {
                    Type = ChatMessageType.System,
                    Content = $"Players online: {players}",
                    Timestamp = DateTime.Now,
                    PlayerName = "System"
                });
                break;

            case "/say":
                if (parts.Length > 1)
                {
                    await ChatService.SendMessageAsync(connectionId!, parts[1], ChatMessageType.Chat);
                }
                else
                {
                    await OnMessageReceived(new ChatMessage
                    {
                        Type = ChatMessageType.Error,
                        Content = "Usage: /say <message>",
                        Timestamp = DateTime.Now,
                        PlayerName = "System"
                    });
                }
                break;

            case "/thunder":
                await ChatService.TriggerThunderAsync();
                await OnMessageReceived(new ChatMessage
                {
                    Type = ChatMessageType.System,
                    Content = "Thunder manually triggered for all players.",
                    Timestamp = DateTime.Now,
                    PlayerName = "System"
                });
                break;

            default:
                await OnMessageReceived(new ChatMessage
                {
                    Type = ChatMessageType.Error,
                    Content = $"Unknown command: {cmd}. Type /help for available commands.",
                    Timestamp = DateTime.Now,
                    PlayerName = "System"
                });
                break;
        }
    }

    private async Task ProcessGameCommand(string command)
    {
        var parts = command.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
        var cmd = parts[0].ToLower();
        string response;

        try
        {
            switch (cmd)
            {
                case "help":
                    response = "Available commands: look [direction], north, south, east, west, inventory, examine";
                    break;

                case "look":
                case "l":
                    if (parts.Length > 1)
                    {
                        // Directional look: "look north", "look east", etc.
                        var lookDirection = parts[1].ToLower();
                        
                        // Normalize direction names
                        lookDirection = lookDirection switch
                        {
                            "n" => "north",
                            "s" => "south",
                            "e" => "east",
                            "w" => "west",
                            "north" => "north",
                            "south" => "south", 
                            "east" => "east",
                            "west" => "west",
                            _ => lookDirection
                        };

                        // Validate direction
                        if (new[] { "north", "south", "east", "west" }.Contains(lookDirection))
                        {
                            response = await GameService.LookInDirectionAsync(playerName, lookDirection);
                        }
                        else
                        {
                            response = $"You cannot look '{parts[1]}'. Try: look north, look south, look east, or look west.";
                        }
                    }
                    else
                    {
                        // Regular look at current room
                        response = await GameService.GetRoomDescriptionAsync(playerName);
                    }
                    break;

                case "inventory":
                case "inv":
                case "i":
                    response = await GameService.GetPlayerInventoryAsync(playerName);
                    break;

                case "north":
                case "n":
                case "south":
                case "s":
                case "east":
                case "e":
                case "west":
                case "w":
                    // Normalize direction names
                    var moveDirection = cmd switch
                    {
                        "n" => "north",
                        "s" => "south",
                        "e" => "east",
                        "w" => "west",
                        _ => cmd
                    };

                    var movementResult = await GameService.MovePlayerAsync(playerName, moveDirection);
                    if (movementResult.Success)
                    {
                        // Send movement confirmation to the moving player first
                        await ChatService.SendGameActionAsync(connectionId!, command, movementResult.Message);
                        
                        // Add a very small delay to ensure database synchronization
                        await Task.Delay(100);
                        
                        // Notify players in the previous room that this player left
                        if (movementResult.PreviousRoom != null)
                        {
                            await ChatService.BroadcastMovementAsync(
                                movementResult.PreviousRoom.Id, 
                                playerName, 
                                $"{playerName} leaves {moveDirection}.",
                                connectionId);
                        }
                        
                        // Notify players in the new room that this player entered
                        if (movementResult.NewRoom != null)
                        {
                            var oppositeDirection = GetOppositeDirection(moveDirection);
                            await ChatService.BroadcastMovementAsync(
                                movementResult.NewRoom.Id, 
                                playerName, 
                                $"{playerName} arrives from the {oppositeDirection}.",
                                connectionId);
                        }

                        // Send new room description to the moving player
                        var newRoomDescription = await GameService.GetRoomDescriptionAsync(playerName);
                        await OnMessageReceived(new ChatMessage
                        {
                            Type = ChatMessageType.Description,
                            Content = newRoomDescription,
                            Timestamp = DateTime.Now.AddMilliseconds(500),
                            PlayerName = "Game"
                        });
                        return; // Early return to avoid duplicate messaging
                    }
                    else
                    {
                        response = movementResult.Message;
                    }
                    break;

                default:
                    response = $"Unknown command: '{command}'. Type 'help' for available commands.";
                    break;
            }

            await ChatService.SendGameActionAsync(connectionId!, command, response);
        }
        catch (Exception ex)
        {
            response = "An error occurred while processing your command.";
            Console.WriteLine($"Error processing game command '{command}': {ex.Message}");
            await ChatService.SendGameActionAsync(connectionId!, command, response);
        }
    }

    private string GetMessageClass(ChatMessageType type)
    {
        return type switch
        {
            ChatMessageType.System => "system",
            ChatMessageType.Description => "description",
            ChatMessageType.Action => "action",
            ChatMessageType.UserCommand => "user-command",
            ChatMessageType.GameResponse => "game-response",
            ChatMessageType.Chat => "chat",
            ChatMessageType.Error => "error",
            ChatMessageType.Atmosphere => "atmosphere",
            _ => ""
        };
    }

    private string GetInputPlaceholder()
    {
        return isProcessing ? "Processing..." : "Enter command or /say <message> to chat...";
    }

    private string GetOppositeDirection(string direction)
    {
        return direction.ToLower() switch
        {
            "north" => "south",
            "south" => "north",
            "east" => "west",
            "west" => "east",
            _ => "somewhere"
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (connectionId != null)
        {
            await ChatService.DisconnectPlayerAsync(connectionId);
        }
    }
}

<script>
    window.scrollToBottom = (elementId) => {
        const element = document.getElementById(elementId);
        if (element) {
            element.scrollTop = element.scrollHeight;
        }
    };
</script>
